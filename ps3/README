PS3: 6 points

The goal of this problem set is to compile Fish abstract syntax down
to MIPS assembly code.

*******************************
IMPORTANT: you must start by installing additional OCaml libraries
using opam to build the starter code.

Run the following:

  opam install ppx_deriving ppx_sexp_conv sexp

from a terminal.

You should then be able to run "make" in this directory without errors.

Additionally, you probably want to install the spim simulator to test
your code. See the "Resources" tab on the course website for links and
instructions.
*******************************

You are to complete the file compile.ml at the places marked with
IMPLEMENT_ME.  There are two big functions to write: one collects up
the set of all variables that occur in a program, and the other
compiles Fish programs down to Mips assembly.  The goal is, if the
Fish program being compiled would return an integer n when executed,
then the compiled code should result in a sequence of instructions
such that when finished running, value n is in register 2, and the
code finishes by jumping to the address that was initially in register
$31 when execution began.  You will submit your code by uploading
compile.ml to GradeScope.

You do not need to do any optimization, or have a particularly fast
compiler to get full credit for this assignment.  On the other
hand, if you want to try to do a few transformations, optimizations,
or simplifications, please feel free.  Just make sure to get the basic
code working correctly first.

I've provided boiler plate code for printing out Mips code so that you
can dump the results into a file, assemble it, and load it using SPIM.
In particular, in order to not include the solutions for the previous
problem set in this starter code, we have set up two ways to run the
compiler. One way runs a parser generated from lex.mll and parse.mly
directly on a .fish source file and then tries to compile it, and the
other runs on a pre-parsed representation called an s-expression that
we have generated by running the reference solution parser on each
file.

More specifically, in the tests/ directory, you will see that for each
file with a .fish extension there is another file with a .sexp
extension. Each .sexp file was generated by running a parser on the
corresponding .fish file to generate an AST, converting the AST to
"s-expression" format, and then writing the s-expression to the .sexp
file.  (S-expressions are a convenient way to represent tree like data
structures in a way that is very simple to parse. You don't have to
understand how they work to do this assignment, but if you want to
learn more about working with S-expressions in OCaml check out this
free book chapter: https://dev.realworldocaml.org/data-serialization.html)

You tell the compiler whether you want to do direct parsing or use sexp
by making the first argument "src" or "sexp" when invoking the compiler.
That is, if you run:

./ps3 src [.fish file to compile]

the code will read the .fish file, try to parse it, run the compiler, and then
print out the compiled MIPS code.  To use this mode, you must actually copy
over a lex/yacc file for lex.mll and parse.mly.  If you did the lex/yacc
solution to ps2, and got it working, feel free to copy your files over and use
this.

Alternately if you run:

./ps3 sexp [.sexp file to compile]

the code will read the .sexp file, convert it back to an AST, run the
compiler, and then print out the compiled MIPS code.

If you used parser combinators, or didn't get a solution to PS2
working, just use the sexp version to test your files.
In the end, the autograder will test your results against the sexp
version.

When you run one of these commands, you can save the output to a file
and then run the spim simulator.  The starter code for the compiler is
set up so that in the emitted assembly code, the body of the Fish
program follows the label "fish_main". In addition, it includes
assembly code for two other procedures called "main" and
"printInt". The former is what the spim simulator will jump to when
executing your program. This main procedure does a jal to go to
"fish_main", and upon returning from it, jumps to "printInt" to print
the contents of register $2. When you run spim on the resulting
assembly file, it will then print out the what the contents of
register 2 were when "fish_main" finishes (which ought to be what the
program returns).

For example, the following commands save the output of compiling in a
file called "tmp.s" and then invokes spim on that file:

$ ./ps3 sexp test/01cexpr_01add.sexp > tmp.s
$ spim -file tmp.s
SPIM Version 8.0 of January 8, 2010
Copyright 1990-2010, James R. Larus.
All Rights Reserved.
See the file README for a full copyright notice.
Loaded: /usr/lib/spim/exceptions.s
16

where the "16" at the end is the value printed by running the compiled code.

WARNING: Your assembly code should NOT modify any caller-saved
registers (or if you do modify them, you need to correctly restore
them before returning) or else the starter code will not work
correctly.
